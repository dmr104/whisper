// This particular file was generated by Claude-Sonnet AI

// Types for Whisper output data
interface WhisperSegment {
  id: number;
  seek: number;
  start: number;
  end: number;
  text: string;
  tokens: number[];
  temperature: number;
  avg_logprob: number;
  compression_ratio: number;
  no_speech_prob: number;
}

interface WhisperOutput {
  text: string;
  segments: WhisperSegment[];
  language: string;
}

// Utility functions for time formatting
class TimeFormatter {
  /**
   * Convert seconds to SRT time format (HH:MM:SS,mmm)
   */
  static toSRTTime(seconds: number): string {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    const milliseconds = Math.floor((seconds % 1) * 1000);
    
    return `${hours.toString().padStart(2, '0')}:${minutes
      .toString()
      .padStart(2, '0')}:${secs.toString().padStart(2, '0')},${milliseconds
      .toString()
      .padStart(3, '0')}`;
  }

  /**
   * Convert seconds to VTT time format (HH:MM:SS.mmm)
   */
  static toVTTTime(seconds: number): string {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    const milliseconds = Math.floor((seconds % 1) * 1000);
    
    return `${hours.toString().padStart(2, '0')}:${minutes
      .toString()
      .padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${milliseconds
      .toString()
      .padStart(3, '0')}`;
  }

  /**
   * Convert seconds to TSV time format (seconds with 3 decimal places)
   */
  static toTSVTime(seconds: number): string {
    return seconds.toFixed(3);
  }
}

// Main formatter class
export class WhisperFormatter {
  private whisperData: WhisperOutput;

  constructor(whisperData?: WhisperOutput) {
    this.whisperData = whisperData || this.getDefaultWhisperData();
  }

  // Example function to provide a default WhisperOutput
  private getDefaultWhisperData(): WhisperOutput {
    return  {
        text: "test",
        segments: [{
            id: 0,
            seek: 0,
            start: 0,
            end: 0,
            text: "test",
            tokens: [1,2,3,4],
            temperature: 0,
            avg_logprob: 0,
            compression_ratio: 0,
            no_speech_prob: 0
        }],
        language: "test"
    };
  }

  public inputMainJsonDataRecord(whisperData: WhisperOutput){
    this.whisperData = whisperData;
  }

  /**
   * Generate TSV format
   * Format: start_time\tend_time\ttext
   */
  public toTSV(): string {
    const header = "start\tend\ttext\n";
    const rows = this.whisperData.segments.map(segment => {
      const startTime = TimeFormatter.toTSVTime(segment.start);
      const endTime = TimeFormatter.toTSVTime(segment.end);
      const text = segment.text.trim().replace(/\t/g, ' '); // Replace tabs in text
      
      return `${startTime}\t${endTime}\t${text}`;
    });

    return header + rows.join('\n');
  }

  /**
   * Generate SRT format
   * Format:
   * 1
   * 00:00:00,000 --> 00:00:05,000
   * Subtitle text
   * 
   */
  public toSRT(): string {
    const subtitles = this.whisperData.segments.map((segment, index) => {
      const sequenceNumber = index + 1;
      const startTime = TimeFormatter.toSRTTime(segment.start);
      const endTime = TimeFormatter.toSRTTime(segment.end);
      const text = segment.text.trim();
      
      return `${sequenceNumber}\n${startTime} --> ${endTime}\n${text}\n`;
    });

    return subtitles.join('\n');
  }

  /**
   * Generate VTT format
   * Format:
   * WEBVTT
   * 
   * 00:00:00.000 --> 00:00:05.000
   * Subtitle text
   * 
   */
  public toVTT(): string {
    const header = "WEBVTT\n\n";
    
    const subtitles = this.whisperData.segments.map(segment => {
      const startTime = TimeFormatter.toVTTTime(segment.start);
      const endTime = TimeFormatter.toVTTTime(segment.end);
      const text = segment.text.trim();
      
      return `${startTime} --> ${endTime}\n${text}\n`;
    });

    return header + subtitles.join('\n');
  }

  /**
   * Clean and prepare text for subtitle formats
   */
  private cleanText(text: string): string {
    return text
      .trim()
      .replace(/\s+/g, ' ') // Replace multiple spaces with single space
      .replace(/[^\w\s.,!?;:'"()-]/g, ''); // Remove special characters except common punctuation
  }

  /**
   * Split long segments into smaller chunks for better readability
   */
  private splitLongSegments(maxCharsPerLine: number = 80): WhisperSegment[] {
    const splitSegments: WhisperSegment[] = [];

    this.whisperData.segments.forEach(segment => {
      if (segment.text.length <= maxCharsPerLine) {
        splitSegments.push(segment);
        return;
      }

      // Split long text into chunks
      const words = segment.text.trim().split(' ');
      const chunks: string[] = [];
      let currentChunk = '';

      words.forEach(word => {
        if ((currentChunk + ' ' + word).length <= maxCharsPerLine) {
          currentChunk += (currentChunk ? ' ' : '') + word;
        } else {
          if (currentChunk) {chunks.push(currentChunk);}
          currentChunk = word;
        }
      });
      
      if (currentChunk) {chunks.push(currentChunk);}

      // Create new segments for each chunk
      const duration = segment.end - segment.start;
      const chunkDuration = duration / chunks.length;

      chunks.forEach((chunk, index) => {
        const newSegment: WhisperSegment = {
          ...segment,
          id: segment.id + index / 100, // Maintain unique IDs
          start: segment.start + (index * chunkDuration),
          end: segment.start + ((index + 1) * chunkDuration),
          text: chunk
        };
        splitSegments.push(newSegment);
      });
    });

    return splitSegments;
  }

  /**
   * Generate optimized SRT with text splitting
   */
  public toOptimizedSRT(maxCharsPerLine: number = 80): string {
    const originalSegments = this.whisperData.segments;
    this.whisperData.segments = this.splitLongSegments(maxCharsPerLine);
    const result = this.toSRT();
    this.whisperData.segments = originalSegments; // Restore original data
    return result;
  }
}